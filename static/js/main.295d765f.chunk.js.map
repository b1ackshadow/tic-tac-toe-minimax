{"version":3,"sources":["components/Status.js","components/GameCell.js","utils.js","components/Main.js","App.js","reportWebVitals.js","index.js"],"names":["Status","status","className","GameCell","cells","idx","handleCellClick","cls","onClick","minimax","board","depth","isMaximizerTurn","result","evaluateGame","bestScore","Number","NEGATIVE_INFINITY","forEach","cell","boardCopy","score","POSITIVE_INFINITY","possibleCombinations","combination","x","y","z","Main","useState","setStatus","Array","fill","setCell","xTurn","setXTurn","value","winner","setWinner","index","newCells","useEffect","toUpperCase","bestMove","filter","each","length","console","log","findBestMove","gameCells","i","push","style","color","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.295d765f.chunk.js","sourcesContent":["import React from \"react\";\n\nexport default function Status({ status }) {\n  return <div className=\"status\">{status}</div>;\n}\n","import React from \"react\";\n\nexport default function GameCell({ cells, idx, handleCellClick }) {\n  let cls = cells[idx] === \"\" ? \"\" : cells[idx] === \"×\" ? \"x\" : \"o\";\n  return (\n    <div\n      className={\"game-cell \" + cls}\n      onClick={() => handleCellClick(idx)}\n    ></div>\n  );\n}\n","const findBestMove = (board) => {\n  //find a best possible move considering the current board state\n  // now its time for minimizer\n  let bestScore = Number.POSITIVE_INFINITY;\n  let bestMove = null;\n\n  //calc depth so that we can limit minimax function.\n  //can  do so by checking how many values are already filled\n\n  const depth = board.filter((each) => each === \"\").length;\n\n  board.forEach((cell, idx) => {\n    // check the score for each possible move\n\n    //check if cell it not empty\n    if (cell !== \"\") return;\n\n    // if cell not empty pretent to make this move and get the score from minimax\n    const boardCopy = [...board];\n    boardCopy[idx] = \"○\";\n\n    //3rd arg true is the indicator of whose turn i.e, maximizer\n    let score = minimax(boardCopy, depth - 1, true);\n\n    console.log(`Move : ${idx + 1} Score : ${score} \\n\\n`);\n    if (score < bestScore) {\n      bestScore = score;\n      bestMove = idx;\n    }\n  });\n  console.log(\"\");\n  return { bestMove, bestScore };\n};\n\nconst minimax = (board, depth, isMaximizerTurn) => {\n  //check for winner\n  const result = evaluateGame(board);\n\n  if (result !== \"\") {\n    // console.log(board, depth);\n    return result === \"×\" ? depth + 1 : -depth - 1;\n  }\n\n  //if depth reached and there is no more moves and no winner so tie\n  if (depth === 0) return depth / 2;\n\n  // No winner and can play still. so check recursively\n\n  if (isMaximizerTurn) {\n    let bestScore = Number.NEGATIVE_INFINITY;\n    board.forEach((cell, idx) => {\n      // check the score for each possible move\n\n      //check if cell it not empty\n      if (cell !== \"\") return;\n\n      // if cell not empty pretent to make this move and get the score from minimax\n      const boardCopy = [...board];\n      boardCopy[idx] = \"×\";\n\n      //3rd arg true is the indicator of whose turn i.e, maximizer\n      let score = minimax(boardCopy, depth - 1, false);\n      // console.log(`Move : ${idx} Score: ${score}`);\n      if (score > bestScore) {\n        bestScore = score;\n      }\n    });\n    return bestScore;\n  } else {\n    let bestScore = Number.POSITIVE_INFINITY;\n    board.forEach((cell, idx) => {\n      // check the score for each possible move\n\n      //check if cell it not empty\n      if (cell !== \"\") return;\n\n      // if cell not empty pretent to make this move and get the score from minimax\n      const boardCopy = [...board];\n      boardCopy[idx] = \"○\";\n\n      //3rd arg true is the indicator of whose turn i.e, maximizer\n      let score = minimax(boardCopy, depth - 1, true);\n      if (score < bestScore) {\n        bestScore = score;\n      }\n    });\n    return bestScore;\n  }\n};\n\nconst possibleCombinations = [\n  [0, 1, 2],\n  [3, 4, 5],\n  [6, 7, 8],\n  [0, 3, 6],\n  [1, 4, 7],\n  [2, 5, 8],\n  [0, 4, 8],\n  [2, 4, 6],\n];\n\nconst evaluateGame = (cells) => {\n  for (let combination of possibleCombinations) {\n    const [x, y, z] = combination;\n    if (cells[x] !== \"\" && cells[x] === cells[y] && cells[y] === cells[z]) {\n      return cells[x];\n    }\n  }\n  return \"\";\n};\n\nexport { evaluateGame, findBestMove };\n","import React, { useState, useEffect } from \"react\";\n\nimport Status from \"./Status\";\nimport GameCell from \"./GameCell\";\nimport { evaluateGame, findBestMove } from \"../utils\";\nimport \"../App.css\";\n\nexport default function Main() {\n  const [status, setStatus] = useState(\"X is next\");\n\n  // let tempArray = [\"×\", \"○\", \"×\", \"○\", \"○\", \"×\", \"\", \"\", \"\"];\n  // let tempArray = [\"×\", \"×\", \"\", \"○\", \"×\", \"×\", \"\", \"○\", \"○\"];\n\n  const [cells, setCell] = useState(new Array(9).fill(\"\"));\n\n  const [xTurn, setXTurn] = useState(true);\n\n  const xValue = \"×\";\n  const oValue = \"○\";\n\n  let value = xTurn ? xValue : oValue;\n\n  const [winner, setWinner] = useState(\"\");\n\n  const handleCellClick = (index) => {\n    if (cells[index] !== \"\" || winner !== \"\") return;\n    let newCells = [...cells];\n    newCells[index] = value;\n    setCell(newCells);\n    setXTurn(!xTurn);\n\n    // evaluate if winner\n    setWinner(evaluateGame(newCells));\n  };\n\n  const resetGame = () => {\n    setCell(new Array(9).fill(\"\"));\n    setWinner(\"\");\n    setXTurn(true);\n    setStatus(\"X is next\");\n  };\n\n  useEffect(() => {\n    if (winner !== \"\") {\n      setStatus(`${winner.toUpperCase()} won!`);\n    } else setStatus(`${xTurn ? \"X\" : \"O\"} is next`);\n  }, [winner, xTurn]);\n\n  useEffect(() => {\n    // move updated so checking minimax\n    if (!xTurn) {\n      const { bestMove } = findBestMove(cells);\n      let newCells = [...cells];\n      newCells[bestMove] = value;\n      setCell(newCells);\n      setXTurn(!xTurn);\n\n      // evaluate if winner\n      setWinner(evaluateGame(newCells));\n    }\n    // console.log({ bestMove, bestScore });\n\n    if (cells.filter((each) => each === \"\").length === 0) {\n      //over no winner draw\n      setStatus(\"Draw :(\");\n    }\n  }, [cells, xTurn, value]);\n  const gameCells = [];\n\n  for (let i = 0; i < 9; i++) {\n    gameCells.push(\n      <GameCell\n        key={i}\n        idx={i}\n        cells={cells}\n        handleCellClick={handleCellClick}\n      />\n    );\n  }\n\n  return (\n    <div className=\"container\">\n      <h1 className=\"title\">\n        Tic <span style={{ color: \"white\" }}>Tac</span> Toe\n      </h1>\n      <div className=\"status-action\">\n        <Status status={status} />\n        <div className=\"reset\" onClick={resetGame}>\n          Reset\n        </div>\n      </div>\n      <div className=\"game-grid\">{gameCells}</div>\n    </div>\n  );\n}\n","import \"./App.css\";\nimport Main from \"./components/Main\";\n\nfunction App() {\n  return <Main />;\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}